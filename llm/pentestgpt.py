import json
import os
from datetime import datetime
from typing import Optional, Tuple
import aiohttp
import asyncio
import logging
from dotenv import load_dotenv

load_dotenv()
logger = logging.getLogger(__name__)

class PentestGPT:
    def __init__(self, api_token: str):
        self.api_token = api_token
        self.base_url = "https://pentestgpt.ai"
        self.headers = {
            'Host': 'pentestgpt.ai',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:128.0) Gecko/20100101 Firefox/128.0',
            'Accept': '*/*',
            'Content-Type': 'text/plain;charset=UTF-8',
            'Origin': 'https://pentestgpt.ai',
            'Cookie': api_token,
        }
        self.history_dir = "chat_history"
        self.session: Optional[aiohttp.ClientSession] = None
        os.makedirs(self.history_dir, exist_ok=True)

    async def __aenter__(self):
        await self.initialize()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()

    async def initialize(self):
        """Initialize the aiohttp session."""
        self.session = aiohttp.ClientSession(headers=self.headers)

    async def close(self):
        """Close the aiohttp session."""
        if self.session:
            await self.session.close()

    def _load_chat_history(self, chat_history_id: str) -> Tuple[Optional[str], Optional[str]]:
        history_file = os.path.join(self.history_dir, f"pentestgpt_{chat_history_id}.json")
        if os.path.exists(history_file):
            with open(history_file, 'r') as f:
                history = json.load(f)
                messages = history.get('messages', [])
                # Return last message for context if available
                last_message = messages[-1] if messages else None
                return last_message['prompt'] if last_message else None, last_message['response'] if last_message else None
        return None, None

    def _save_chat_history(self, chat_history_id: str, prompt: str, response: str):
        history_file = os.path.join(self.history_dir, f"pentestgpt_{chat_history_id}.json")
        
        if os.path.exists(history_file):
            with open(history_file, 'r') as f:
                history = json.load(f)
        else:
            history = {
                'created_at': datetime.now().isoformat(),
                'model': 'pentestgpt',
                'messages': []
            }

        history['messages'].append({
            'timestamp': datetime.now().isoformat(),
            'prompt': prompt,
            'response': response
        })

        with open(history_file, 'w') as f:
            json.dump(history, f, indent=2)

    async def chat(self, message: str, chat_history_id: Optional[str] = None) -> str:
        if not chat_history_id:
            chat_history_id = datetime.now().strftime("%Y%m%d_%H%M%S")

        # Load chat history for context
        last_prompt, last_response = self._load_chat_history(chat_history_id)

        payload = {
            "messages": [
                {"role": "system", "content": ""},
                {"role": "user", "content": message},
                {"role": "assistant", "content": ""}
            ],
            "chatSettings": {
                "model": "mistral-medium",
                "includeProfileContext": True,
                "embeddingsProvider": "openai"
            },
            "isRetrieval": False,
            "isContinuation": False,
            "isRagEnabled": True
        }

        try:
            async with self.session.post(
                f"{self.base_url}/api/chat/mistral",
                json=payload
            ) as response:
                if response.status == 200:
                    full_response = ""
                    async for line in response.content:
                        if line:
                            data = line.decode('utf-8')
                            if data.startswith('0:'):
                                # Remove the '0:' prefix and clean up the content
                                content = data[2:]
                                # Remove quotes and extra characters
                                content = content.replace('"', '').replace('"', '')
                                # Remove any remaining special characters
                                content = ''.join(char for char in content if char.isalnum() or char in ' .,!?')
                                full_response += content

                    # Final cleanup
                    full_response = full_response.strip()
                    # Normalize spaces
                    full_response = ' '.join(full_response.split())
                    
                    # Save chat history
                    self._save_chat_history(chat_history_id, message, full_response)
                    return full_response
                else:
                    error_msg = f"Request failed with status {response.status}"
                    logger.error(error_msg)
                    return error_msg

        except aiohttp.ClientError as e:
            error_msg = f"Error making request: {e}"
            logger.error(error_msg)
            return error_msg

async def pentestgpt_api(message: str, chat_history_id: str = None, api_token: str = None):
    try:
        if not api_token:
            logger.error("PentestGPT API token not provided")

            
        async with PentestGPT(api_token) as pentestgpt:
            response = await pentestgpt.chat(message, chat_history_id)
            return response
    except Exception as e:
        logger.error(f"Error in pentestgpt_api: {e}")
        # Fallback to BlackboxAI on any error


if __name__ == "__main__":
    async def main():
        api_token = "" # TODO: Add API token
        chat_history_id = "test_conversation"
        
        while True:
            prompt = input("You: ")
            if prompt.lower() in ['exit', 'quit']:
                break
                
            response = await pentestgpt_api(prompt, chat_history_id, api_token)
            print(f"Assistant: {response}\n")
            
    asyncio.run(main())